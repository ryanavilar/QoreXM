import { All } from "./all";
import { Any } from "./any";
import { AsIterable } from "./asIterable";
import { Associate } from "./associate";
import { AssociateBy } from "./associateBy";
import { Average } from "./average";
import { Chunk } from "./chunk";
import { Contains } from "./contains";
import { Count } from "./count";
import { Distinct } from "./distinct";
import { DistinctBy } from "./distinctBy";
import { Drop } from "./drop";
import { DropWhile } from "./dropWhile";
import { ElementAt } from "./elementAt";
import { ElementAtOrElse } from "./elementAtOrElse";
import { ElementAtOrNull } from "./elementAtOrNull";
import { Filter } from "./filter";
import { FilterIndexed } from "./filterIndexed";
import { FilterNot } from "./filterNot";
import { FilterNotNull } from "./filterNotNull";
import { First } from "./first";
import { FirstOrNull } from "./firstOrNull";
import { FlatMap } from "./flatMap";
import { Flatten } from "./flatten";
import { Fold } from "./fold";
import { FoldIndexed } from "./foldIndexed";
import { ForEach } from "./forEach";
import { ForEachIndexed } from "./forEachIndexed";
import { GroupBy } from "./groupBy";
import { IndexOf } from "./indexOf";
import { IndexOfFirst } from "./indexOfFirst";
import { IndexOfLast } from "./indexOfLast";
import { JoinToString } from "./joinToString";
import { Last } from "./last";
import { LastOrNull } from "./lastOrNull";
import { Map } from "./map";
import { MapIndexed } from "./mapIndexed";
import { MapNotNull } from "./mapNotNull";
import { Max } from "./max";
import { MaxBy } from "./maxBy";
import { MaxWith } from "./maxWith";
import { Merge } from "./merge";
import { Min } from "./min";
import { MinBy } from "./minBy";
import { Minus } from "./minus";
import { MinWith } from "./minWith";
import { None } from "./none";
import { OnEach } from "./onEach";
import { Partition } from "./partition";
import { Plus } from "./plus";
import { Reduce } from "./reduce";
import { ReduceIndexed } from "./reduceIndexed";
import { Reverse } from "./reverse";
import { Single } from "./single";
import { SingleOrNull } from "./singleOrNull";
import { Sorted } from "./sorted";
import { SortedBy } from "./sortedBy";
import { SortedByDescending } from "./sortedByDescending";
import { SortedDescending } from "./sortedDescending";
import { SortedWith } from "./sortedWith";
import { Sum } from "./sum";
import { SumBy } from "./sumBy";
import { Take } from "./take";
import { TakeWhile } from "./takeWhile";
import { ToArray } from "./toArray";
import { ToMap } from "./toMap";
import { ToSet } from "./toSet";
import { Unzip } from "./unzip";
import { WithIndex } from "./withIndex";
import { Zip } from "./zip";
/**
 * @hidden
 */
export interface SequenceOperators<T> extends All, Any, AsIterable, Associate, AssociateBy<T>, Average, Chunk, Contains, Count, Distinct, DistinctBy, Drop, DropWhile, ElementAt, ElementAtOrElse, ElementAtOrNull, Filter, FilterIndexed, FilterNot, FilterNotNull, First, FirstOrNull, FlatMap, Flatten, Fold, FoldIndexed, ForEach, ForEachIndexed, GroupBy, IndexOf, IndexOfFirst, IndexOfLast, JoinToString, Last, LastOrNull, Map, MapIndexed, MapNotNull, Max, MaxBy, MaxWith, Merge, Min, MinBy, Minus, MinWith, None, OnEach, Partition, Plus, Reduce, ReduceIndexed, Reverse, Single, SingleOrNull, Sorted, SortedBy, SortedByDescending, SortedDescending, SortedWith, Sum, SumBy, Take, TakeWhile, ToArray, ToMap, ToSet, Unzip, WithIndex, Zip {
}
/**
 * A Sequence provides a fluent functional API consisting
 * of various intermediate and terminal operations for processing the iterated data.
 * The operations are evaluated lazily to avoid examining all of the input data
 * when it's not necessary. Sequences can be iterated only once.
 */
export default interface Sequence<T> extends SequenceOperators<T> {
    readonly iterator: Iterator<T>;
}
export declare function sequenceOf<T>(...args: Array<T>): Sequence<T>;
export declare function emptySequence<T>(): Sequence<T>;
export declare function asSequence<T>(iterable: Iterable<T>): Sequence<T>;
export declare function createSequence<T>(iterator: Iterator<T>): Sequence<T>;
export declare function isSequence<T>(object: any): object is Sequence<T>;
export declare function extendSequence(mixin: {
    new (): any;
}): void;
export declare function generateSequence<T>(nextFunction: () => T | null | undefined): Sequence<T>;
export declare function generateSequence<T>(seedFunction: () => T | null | undefined, nextFunction: (item: T) => T | null | undefined): Sequence<T>;
export declare function generateSequence<T>(seed: T | null | undefined, nextFunction: (item: T) => T | null | undefined): Sequence<T>;
export declare function range(start: number, endInclusive: number, step?: number): Sequence<number>;
