Object.defineProperty(exports, "__esModule", { value: true });
var Sequence_1 = require("./Sequence");
var Merge = /** @class */ (function () {
    function Merge() {
    }
    /**
     * Merges the elements of both sequences into a new sequence. Each element of this sequence is eventually replaced with
     * an element of the other sequence by comparing results of the given `selector` function. If no value is found in the other
     * sequence the element is retained. New elements of the other sequence are appended to the end of the new sequence or
     * prepended to the start of the new sequence, if `prependNewValues` is set to `true`. This operation is not lazy evaluated.
     *
     * @param {Sequence<T>} other
     * @param {(value: T) => S} selector
     * @param prependNewValues
     * @returns {Sequence<T>}
     */
    Merge.prototype.merge = function (other, selector, prependNewValues) {
        if (prependNewValues === void 0) { prependNewValues = false; }
        var mergeValues = Sequence_1.isSequence(other)
            ? other.toArray()
            : Sequence_1.asSequence(other).toArray();
        var leftValues = this.toArray();
        var result = leftValues.map(function (left) {
            var selected = selector(left);
            var right = Sequence_1.asSequence(mergeValues)
                .find(function (it) { return selector(it) === selected; });
            if (right != null) {
                mergeValues = mergeValues.filter(function (it) { return it !== right; });
                return right;
            }
            else {
                return left;
            }
        });
        if (prependNewValues) {
            return Sequence_1.asSequence(mergeValues.concat(result));
        }
        else {
            return Sequence_1.asSequence(result.concat(mergeValues));
        }
    };
    return Merge;
}());
exports.Merge = Merge;
//# sourceMappingURL=merge.js.map