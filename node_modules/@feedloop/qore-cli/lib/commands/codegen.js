"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const voca_1 = tslib_1.__importDefault(require("voca"));
const prettier_1 = tslib_1.__importDefault(require("prettier"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const index_1 = tslib_1.__importDefault(require("@feedloop/qore-sdk/lib/project/index"));
const export_schema_1 = tslib_1.__importDefault(require("./export-schema"));
const flags_1 = require("../flags");
class Codegen extends command_1.Command {
    constructor() {
        super(...arguments);
        this.writeFieldTypes = new Set([
            "text",
            "number",
            "date",
            "file",
            "password",
            "select",
            "boolean",
            "select",
            "relation"
        ]);
    }
    readFieldType(field) {
        switch (field.type) {
            case "text":
            case "file":
            case "password":
                return "string";
            case "role":
                return "{id: string; displayField: string}";
            case "relation":
                if (field.multiple)
                    return `{nodes: ${voca_1.default.capitalize(field.id === "person" ? "member" : field.id)}TableRow[]}`;
                return `${voca_1.default.capitalize(field.id === "person" ? "member" : field.id)}TableRow${field.multiple ? "[]" : ""}`;
            case "rollup":
                return "number";
            case "date":
                return "Date";
            case "select":
                return field.select.map(select => `"${select}"`).join("|");
            case "lookup":
            case "formula":
                if (field.returnType === "table")
                    return "{id: string; displayField: string}";
                if (field.returnType === "text")
                    return "string";
                return field.returnType;
            default:
                return field.type;
        }
    }
    writeFieldType(field) {
        switch (field.type) {
            case "text":
            case "file":
            case "password":
            case "role":
                return "string";
            case "relation":
                return "string[]";
            case "date":
                return "Date";
            case "select":
                return field.select.map(select => `"${select}"`).join("|");
            default:
                return field.type;
        }
    }
    isWriteField(field) {
        return this.writeFieldTypes.has(field.type);
    }
    async run() {
        try {
            const { args, flags } = this.parse(Codegen);
            const configs = await flags_1.promptFlags(flags, Codegen.flags);
            const schema = await export_schema_1.default.getSchema(configs);
            await export_schema_1.default.run([
                "--project",
                configs.project,
                "--org",
                configs.org,
                "--token",
                configs.token
            ]);
            const idField = { id: "id", type: "text", name: "id" };
            const typeDef = `
      // ${Codegen.warningMessage}

      /// <reference types="@feedloop/qore-client" />
      import { QoreSchema } from "@feedloop/qore-client";

      declare module "@feedloop/qore-client" {
        ${schema.tables
                .map(({ id, fields }) => `
              type ${voca_1.default.capitalize(id)}TableRow = {${[idField, ...fields]
                .filter(field => field.type !== "action")
                .map(field => `
              ${field.id}: ${this.readFieldType(field)};`)
                .join("")}}`)
                .join("\n")}

        ${schema.views
                .map(({ id, parameters, sorts, fields }) => `
              type ${voca_1.default.capitalize(id)}ViewRow = {
                read: {${[idField, ...fields]
                .filter(field => field.type !== "action")
                .map(field => `
                ${field.id}: ${this.readFieldType(field)};`)
                .join("")}}
                write: {${fields
                .filter(vield => this.isWriteField(vield))
                .map(field => `
                    ${field.id}: ${this.writeFieldType(field)};`)
                .join("")}
                }
                params: {${parameters
                .map(param => `
                    ${param.slug}${param.required ? "" : "?"}: ${param.type === "text" ? "string" : "number"};`)
                .join("")}
                  ${sorts
                .filter(sort => !!sort.order && !!sort.by)
                // group order by "sort.by"
                .reduce((group, sort) => {
                const targetIdx = group.findIndex(sortGroup => sortGroup.by === sort.by);
                if (group[targetIdx]) {
                    group[targetIdx].order.push(sort.order);
                }
                else {
                    group.push({
                        by: sort.by,
                        order: [sort.order]
                    });
                }
                return group;
            }, [])
                .map(sortGroup => `"$by.${sortGroup.by}"?: ${sortGroup.order
                .map(order => `"${order}"`)
                .join("|")};`)
                .join("")}
                }
                actions: {${fields
                .filter((vield) => vield.type === "action")
                .map(action => `${action.id}: {
                    ${action.parameters.map(param => `${param.slug}${!param.required && "?"}: ${param.type === "text" ? "string" : param.type}`)}
                  }`)}
                }
              }`)
                .join("\n")}

        interface ProjectSchema extends QoreSchema {
          ${schema.views
                .map(view => `${view.id}: ${voca_1.default.capitalize(view.id)}ViewRow;`)
                .join("")}
        }
      }
    `;
            fs_1.default.writeFileSync(path_1.default.resolve(process.cwd() + "/qore-env.d.ts"), prettier_1.default.format(typeDef, { parser: "babel-ts" }), {
                encoding: "utf8"
            });
            await Codegen.writeConfigFile(configs);
        }
        catch (error) {
            console.error(error.message);
            throw error;
        }
    }
}
exports.default = Codegen;
Codegen.warningMessage = "[WARNING] This file is generated by running `$ qore codegen` on your root project, please do not edit";
Codegen.description = "Generate qore project files";
Codegen.examples = [`$ qore codegen --project projectId --org orgId`];
Codegen.flags = Object.assign({}, flags_1.configFlags);
Codegen.writeConfigFile = async (configs, destination) => {
    var _a;
    const project = index_1.default({
        organizationId: configs.org,
        projectId: configs.project
    });
    await project.auth.signInWithUserToken(configs.token);
    const authConfig = await project.authConfig();
    fs_extra_1.default.writeJSONSync(path_1.default.resolve(destination || process.cwd(), "qore.config.json"), {
        version: "v1",
        endpoint: "https://stg-qore-app.qorebase.io",
        projectId: configs.project,
        organizationId: configs.org,
        authenticationId: (_a = authConfig.password) === null || _a === void 0 ? void 0 : _a.id,
        WARNING: Codegen.warningMessage
    }, { spaces: 2 });
};
